// LICENSE: GNU GPL v3 You should have received a copy of the GNU General
// Public License along with this program. If not, see
// https://www.gnu.org/licenses/.

// File: ogtf.mjs
// defines the main open guide typesetting framework functions

const ogtf = {};

import getformfields from './formreader.mjs';
import postData from './fetch.mjs';
import downloadFile from './download.mjs';
import uploadFiles from './file-upload.mjs';
import {createMetaElement} from './inputfields.mjs';
import {addelem, addbibitems, getAllBibData} from './bibitems.mjs';
import {bibpage} from './bibpage.mjs';

const nonauxfiles =[
  /^all-bibinfo\.json$/,
  /^assignedto\.txt/,
  /^biblast.*$/,
  /^bibliography\.json$/,
  /^archived$/,
  /^citationsfixed$/,
  /^extracted-bib\.txt$/,
  /^main\.[a-z]*$/,
  /^mainupload\.[a-z]*$/,
  /^metadata\.json$/,
  /^metadata\.yaml$/,
  /^oge-settings\.json$/
];

const editableexts = [
  'bash',
  'bib',
  'bst',
  'c',
  'cjs',
  'cls',
  'conf',
  'cpp',
  'css',
  'csv',
  'dirs',
  'eps',
  'h',
  'hs',
  'htm',
  'html',
  'js',
  'json',
  'jsonc',
  'latex',
  'log',
  'ltx',
  'lua',
  'markdown',
  'md',
  'mjs',
  'out',
  'php',
  'ps',
  'py',
  'ris',
  'r',
  'rasi',
  'rs',
  'rss',
  'rtf',
  'sh',
  'sty',
  'svg',
  'task',
  'tex',
  'txt',
  'xhtml',
  'xml',
  'yaml',
  'yml',
  'zsh'
];

const editwarnings = [
  [/^all-bibinfo\.json$/, 'this file is autogenerated by the ' +
   'bibliography section above and will be overwritten if it ' +
   'changes'],
  [/^assignedto\.txt$/, 'this file tracks which site user has ' +
    'been charged with this assignment and will be overwritten if ' +
    'the reassign widget is used'
  ],
  [/^biblast.*$/, false],
  [/^bibliography\.json$/, 'this file is autogenerated by the ' +
   'bibliography section above and will be overwritten if it ' +
   'changes'],
  [/^extracted-bib\.txt$/, 'this file was extracted from the uploaded ' +
   'document and will get overwritten if a new one is uploaded.'],
  [/^oge-settings\.json$/,
   'this file controls how the editor works for this document; ' +
   'do not edit it unless you know how it works'],
  [/^main\.[a-z]*$/, false],
  [/^mainupload\.[a-z]*$/, false],
  [/^metadata\.json$/,
   'this file is autogenerated by the metadata section above and ' +
   'will be overwritten if it changes'],
  [/^metadata\.yaml$/,
   'this file is autogenerated by the metadata section above and ' +
   'will be overwritten if it changes']
];

const exticons = {
  "md": "draft",
  "epub": "install_mobile",
  "html": "public",
  "pdf": "picture_as_pdf",
  "zip": "folder_zip"
}

// to save some typing
function byid(id) {
  return document.getElementById(id);
}

function editUrl(assignmentType, assignmentId, filename) {
  return `/${window.urlbase}/editor` +
    '?project=' + encodeURIComponent(window.projectname) +
    '&username=' + encodeURIComponent(window.username) +
    '&accesskey=' + encodeURIComponent(window.loginaccesskey) +
    '&assignmentType=' + encodeURIComponent(assignmentType) +
    '&assignmentId=' + encodeURIComponent(assignmentId) +
    '&filename=' + encodeURIComponent(filename);
}

function bibchangeddialog(opts) {
  const {fromcard, goto} = opts;
  const dialog = addelem({
    parent: document.body,
    tag: 'dialog'
  });
  const artcl = addelem({
    parent: dialog,
    tag: 'article'
  });
  const p = addelem({
    parent: artcl,
    tag: 'p',
    innerHTML: 'There are unsaved bibliography changes.'
  });
  const ftr = addelem({
    parent: artcl,
    tag: 'footer'
  });
  const discardbtn = addelem({
    parent: ftr,
    tag: 'button',
    type: 'button',
    innerHTML: 'discard changes',
    classes: ['secondary'],
    onclick: () => {
      dialog.removeAttribute('open');
      fromcard.biblastsaved = Date.now();
      ogtf.loadhash(goto);
    }
  });
  const savechangesbtn = addelem({
    parent: ftr,
    tag: 'button',
    type: 'button',
    innerHTML: 'save changes',
    onclick: async () => {
      savechangesbtn.setAttribute('aria-busy', 'true');
      savechangesbtn.innerHTML = 'saving …';
      if (!fromcard?.bibsavebutton) return;
      const clickres = await fromcard.bibsavebutton.onclick();
      dialog.removeAttribute('open');
      if (clickres) {
        fromcard.biblastsaved = Date.now();
        ogtf.loadhash(goto);
      }
    }
  });
  dialog.setAttribute('open', 'true');
  return dialog;
}

function metadatachangedialog(opts) {
  const {fromcard, goto} = opts;
  const dialog = addelem({
    parent: document.body,
    tag: 'dialog'
  });
  const artcl = addelem({
    parent: dialog,
    tag: 'article'
  });
  const p = addelem({
    parent: artcl,
    tag: 'p',
    innerHTML: 'There are unsaved metadata changes.'
  });
  const ftr = addelem({
    parent: artcl,
    tag: 'footer'
  });
  const discardbtn = addelem({
    parent: ftr,
    tag: 'button',
    type: 'button',
    innerHTML: 'discard changes',
    classes: ['secondary'],
    onclick: () => {
      dialog.removeAttribute('open');
      fromcard.metadatachanged = false;
      ogtf.loadhash(goto);
    }
  });
  const savechangesbtn = addelem({
    parent: ftr,
    tag: 'button',
    type: 'button',
    innerHTML: 'save changes',
    onclick: async () => {
      savechangesbtn.setAttribute('aria-busy', 'true');
      savechangesbtn.innerHTML = 'saving …';
      if (!fromcard?.metadataButton) return;
      await fromcard.metadataButton.onclick();
      dialog.removeAttribute('open');
      fromcard.metadatachanged = false;
      ogtf.loadhash(goto);
    }
  })
  dialog.setAttribute('open', 'true');
  return dialog;
}

function proofUrl(key) {
  return `/${window.urlbase}/proofs?key=` + encodeURIComponent(key);
}

function iseditable(fn) {
  const ext = fn.replace(/^.*\.([^\.]*)$/,'$1');
  return (editableexts.indexOf(ext) != -1);
}

async function postJSON(data) {
  const url = `/${window.urlbase}/json`;
  const res = await postData(url, data);
  return res;
}

// makes one of the buttons near the top of the projects
// page a different color
ogtf.activebutton = function(h) {
  const mainnav = byid('projectmainnav');
  if (!mainnav) return;
  const bb = mainnav.getElementsByTagName('a');
  for (const b of bb) {
    b.classList.remove('outline', 'contrast');
  }
  const btn = byid(h + 'button');
  if (!btn) { return; }
  btn.classList.add('outline', 'contrast');
}

// creates an entry for a given article, review or contribution
ogtf.assignmentcard = function(
  assignmentType, assignmentId, assignmentInfo, sect) {
  const idheading = addelem({
    tag: 'h3',
    parent: sect
  });
  const idlabel = addelem({
    tag: 'span',
    parent: idheading
  });
  const card = addelem({
    tag: 'article',
    parent: sect,
    mysection: sect,
    isarchived: assignmentInfo?.isarchived ?? false,
    assignmentType: assignmentType,
    biblastapplied: assignmentInfo?.biblastapplied ?? -1,
    classes: [
      'assignment',
      'ogtf-' + assignmentType
    ]
  });
  // put at start
  //sect.insertBefore(card, sect.newassignmentButton.nextSibling);
  card.hdrw = addelem({
    tag: 'header',
    parent: card,
    classes: ['assignmenttop']
  });
  card.hdr = addelem({
    tag: 'div',
    parent: card.hdrw
  });
  card.hdrleft = addelem({
    tag: 'div',
    parent: card.hdr
  });
  card.idinput = addelem({
    tag: 'input',
    type: 'text',
    classes: ['assignmentidinput'],
    placeholder: 'new document id',
    parent: card.hdrleft,
    mycard: card,
    oninput: function() {
      this.removeAttribute('aria-invalid');
    },
    onchange: function() {
      if (!(/^[A-Za-z0-9]+$/.test(this.value))) {
        this.setAttribute('aria-invalid', 'true');
        return;
      }
      this.mycard.assignmentId = this.value;
      window.skiphashchange = true;
      const newid = `#assignment-` +
        `${this.mycard.assignmentType}-${this.mycard.assignmentId}`;
      ogtf.currentassignment = {
        assignmentType: this.mycard.assignmentType,
        assignmentId: this.mycard.assignmentId
      }
      if (this.mycard?.editbibntBtn) {
        this.mycard.editbibntBtn.href = newid
          .replace('#assignment-', '#bibliography-');
      }
      if (this.mycard?.editbibBtn) {
        this.mycard.editbibBtn.href = newid
          .replace('#assignment-', '#bibliography-');
      }
      this.mycard.mysection.id = newid;
      window.location.hash = newid;
      this.mycard.clearmessage();
      if (this?.mycard?.assignWidget) {
        const v = this.mycard.assignWidget.value;
        if (v == '') {
          this.mycard.assignWidget.value = window.username;
          this.mycard.assignWidget.onchange();
        }
      }
      this.mycard.updateTitle();
      if (this.mycard.updateeditsection) {
        this.mycard.updateeditsection();
      }
      setTimeout(
        () => {
          this.mycard.openNext();
        }, 300
      );
    }
  });
  card.idlabel = idlabel;
  card.assignmentId = (assignmentId.endsWith('ogtfnew'))
    ? '' : assignmentId;
  card.idinput.value = card.assignmentId;
  card.hdrcentral = addelem({
    tag: 'div',
    classes: ['assignmentheader'],
    parent: card.hdr
  });
  card.hdrright = addelem({
    tag: 'div',
    parent: card.hdr
  });
  if (card.isarchived) {
    card.hdrright.style.display = 'none';
  }
  card.assignWidgetLabel = addelem({
    tag: 'label',
    parent: card.hdrright,
    htmlFor: 'assignwidget',
    innerHTML: 'Reassign to'
  });
  card.assignWidget = addelem({
    tag: 'select',
    parent: card.hdrright,
    myAssignmentType: assignmentType,
    mycard: card,
    onchange: async function() {
      const assignmentId = this.mycard.assignmentId;
      const v = this.value;
      if (!v || v == '') return;
      const l = this.mycard.assignWidgetLabel;
      l.innerHTML = 'reassigning …',
      l.setAttribute('aria-busy', 'true');
      const resp = await ogtf.editorquery({
        postcmd: 'assignto',
        assignmentType: this.myAssignmentType,
        assignmentId: assignmentId,
        towhom: v
      });
      l.removeAttribute('aria-busy');
      if (resp?.success) {
        l.classList.add('successconfirm');
        l.innerHTML = `<span class="material-symbols-outlined">check</span> reassigned`;
        setTimeout(() => {
          l.classList.remove('successconfirm');
          l.innerHTML = 'Reassign to'
        }, 2000);
      } else {
        l.innerHTML = 'Reassign to';
      }
    }
  });
  card.assignChooseOpt = addelem({
    tag: 'option',
    parent: card.assignWidget,
    disabled: true,
    value: '',
    innerHTML: 'choose user …'
  });
  card.assignWidget.setAttribute('aria-label','Choose user …')
  card.assignWidget.setAttribute('name','reassign')
  card.assignedTo = assignmentInfo.assignedTo ?? '';
  card.fillnames = async function() {
    const resp = await ogtf.editorquery({
      postcmd: 'allusers'
    });
    if (!resp?.usersinfo) return;
    const users = resp.usersinfo;
    const sorteduserids = Object.keys(users).sort(
      (a, b) => (users[a].name.localeCompare(users[b].name))
    );
    for (const userid of sorteduserids) {
      const opt = addelem({
        tag: 'option',
        parent: card.assignWidget,
        innerHTML: users[userid].name,
        selected: (userid == this.assignedTo),
        value: userid
      });
    }
  }
  card.fillnames();
  card.updateTitle = function() {
    if (this.assignmentId == '') {
      this.idinput.style.display = 'inline';
      this.idlabel.style.display = 'none';
      this.hdrright.style.display = 'none';
      // TODO: hide assignment widget
      this.hdrcentral.innerHTML = '';
      return;
    }
    this.idinput.style.display = 'none';
    this.idlabel.style.display = 'inline';
    this.hdrright.style.display = 'inline-block';
    this.idlabel.innerHTML = 'Assignment: ' + this.assignmentId;
    const mtemte = this.getElementsByClassName("metaelement");
    let display = this?.mydisplay ?? '';
    const origdisplay = display;
    for (const mte of mtemte) {
      if (!mte?.mykey) { continue; }
      const u = (mte.mykey.toUpperCase());
      if (display.indexOf(u) !== -1) {
        const elemrep = mte.getDisplay();
        if (elemrep == '') { continue; }
        display = display.replaceAll(u, mte.getDisplay());
      }
    }
    if (display != origdisplay) {
      this.hdrcentral.innerHTML = display;
    } else {
      this.hdrcentral.innerHTML = '';
    }
  }

  card.contents = addelem({
    tag: 'div',
    parent: card,
    classes: ['assignmentinner']
  });
  // get information about the assignment type from project settings
  const projectSettings = window.projects[window.projectname];
  const assignmentTypes = projectSettings.assignmentTypes ?? {};
  const assignTypeSpec = assignmentTypes[assignmentType];
  card.mydisplay = assignTypeSpec.display ?? '';
  const metaSpec = assignTypeSpec.metadata;
  card.hasMetaData = false;
  // metadata bloc
  card.metablock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.metalabel = addelem({
    tag: 'summary',
    parent: card.metablock,
    innerHTML: 'Metadata'
  });
  card.metafields = addelem({
    tag: 'div',
    parent: card.metablock
  });
  card.currnumgrid = false;
  for (let i  = 0; i < Object.keys(metaSpec).length; i++) {
    const metakey = Object.keys(metaSpec)[i];
    const metakeyspec = metaSpec[metakey];
    let restoreinfo = '';
    if (assignmentInfo?.metadata?.[metakey]) {
      restoreinfo = assignmentInfo.metadata[metakey];
      card.hasMetaData = true;
    }
    const metafield = createMetaElement(metakey,
      metakeyspec, restoreinfo);
    card.metafields.appendChild(metafield);
    if (!card.currnumgrid && (metakeyspec?.inputtype == 'number')) {
      card.currnumgrid = addelem({
        tag: 'div',
        classes: ['grid','numberfieldgrid'],
        parent: card.metafields
      });
      card.currnumgrid.appendChild(metafield);
    }
    if (card.currnumgrid && (metakeyspec?.inputtype == 'number')) {
      card.currnumgrid.appendChild(metafield);
    }
    if (!(metakeyspec?.inputtype == 'number')) {
      card.currnumgrid = false;
    }
  }
  card.metadataButton = addelem({
    tag: 'button',
    type: 'button',
    innerHTML: 'save metadata',
    mycard: card,
    parent: card.metafields,
    onclick: async function() {
      if (!this?.mycard?.assignmentId) {
        this.mycard.reporterror('Cannot save metadata until a document ' +
          'id has been set.');
        return;
      }
      const assignmentId = this.mycard.assignmentId;
      this.mycard.clearmessage();
      this.innerHTML = 'saving metadata …';
      this.setAttribute('aria-busy', 'true');
      const metadata = card.getallmetadata();
      // clean metadata of empty junk
      for (const mfield in metadata) {
        if (metadata[mfield] === '') {
          delete(metadata[mfield]);
          continue;
        }
        if (Array.isArray(metadata[mfield])) {
          let anything = false;
          for (const arrayelem of metadata[mfield]) {
            if (typeof arrayelem == "string" &&
                arrayelem != '') {
              anything = true;
              break;
            }
            if (typeof arrayelem == "object") {
              for (const mkey in arrayelem) {
                if (arrayelem[mkey] != '') {
                  anything = true;
                  break;
                }
              }
            }
            if (anything) { break; }
          }
          if (!anything) {
            delete(metadata[mfield]);
          }
        }
      }
      const req = {};
      req.assignmentId = assignmentId;
      req.assignmentType = this.mycard.assignmentType;
      req.metadata = metadata;
      req.postcmd = 'savemetadata';
      const resp = await ogtf.editorquery(req);
      this.innerHTML = 'save metadata';
      this.removeAttribute('aria-busy');
      if (!resp) { return; }
      if (!("success" in resp) || (!resp.success)) { return; }
      this.mycard.okmessage("Metadata saved.", true);
      this.mycard.metadatachanged = false;
      this.mycard.hasMetaData = true;
      this.mycard.updateTitle();
      this.mycard.openNext();
    }
  });
  // changing metadata enables save button
  const inpinp = card.metafields.getElementsByTagName("input");
  const txtatxta = card.metafields.getElementsByTagName("textarea");
  const selsel = card.metafields.getElementsByTagName("select");
  for (const elem of [...inpinp, ...txtatxta, ...selsel]) {
    elem.addEventListener("input", () => {
      card.clearmessage();
      card.metadatachanged = true;
    });
    elem.addEventListener("change", () => {
      card.clearmessage();
      card.metadatachanged = true;
    });
  }
  card.getallmetadata = function() {
    const mdata = {};
    const metaelements = card.getElementsByClassName("metaelement");
    for (const metaelement of metaelements) {
      if (!metaelement?.mykey) { continue; }
      mdata[metaelement.mykey] = metaelement.getValue();
    }
    return mdata;
  }
  //
  // Upload block
  //
  card.uploadblock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.uploadlabel = addelem({
    tag: 'summary',
    parent: card.uploadblock,
    innerHTML: 'Uploads'
  });
  card.uploadinner = addelem({
    tag: 'div',
    parent: card.uploadblock
  });
  let filenames = [];
  if ("filenames" in assignmentInfo) {
    filenames = assignmentInfo.filenames;
  }
  card.filenames = filenames;
  card.mainuploadext = '';
  for (const filename of filenames) {
    if (filename.substr(0,11) == 'mainupload.') {
      card.mainuploadext = filename.substr(11);
      break;
    }
  }
  card.uploadmainlabel = addelem({
    tag: 'label',
    parent: card.uploadinner
  });
  card.uploadmaingrid = addelem({
    tag: 'div',
    parent: card.uploadinner,
    classes: ['grid']
  });
  card.uploadmaingridleft = addelem({
    tag: 'div',
    parent: card.uploadmaingrid
  });
  card.uploadmaininputloading = addelem({
    tag: 'div',
    parent: card.uploadmaingridleft,
    innerHTML: 'uploading'
  });
  card.uploadmaininputloading.style.display = 'none';
  card.uploadmaininput = addelem({
    tag: 'input',
    type: 'file',
    parent: card.uploadmaingridleft,
    mycard: card,
    accept: '.docx, .tex, .md, .markdown, .htm, ' +
      '.html, .xhtml, .epub, .ltx, .latex, .rtf, .odt',
    onchange: async function() {
      if (this.value == '') {
        return;
      }
      if (!this?.mycard?.assignmentId) {
        this.mycard.reporterror('Cannot upload a file until a ' +
          'document id has been set.');
        return;
      }
      this.mycard.clearmessage();
      const req = {};
      req.uploadtype = 'mainfile';
      req.assignmentType = this.mycard.assignmentType;
      req.assignmentId = this.mycard.assignmentId;
      this.mycard.uploadmaininputloading.style.display = 'inline-block';
      this.mycard.uploadmaininputloading.setAttribute('aria-busy', 'true');
      this.style.display = 'none';
      const resp = await ogtf.editorupload(this, req);
      this.style.display = 'inline';
      this.mycard.uploadmaininputloading.style.display = 'none';
      this.mycard.uploadmaininputloading.removeAttribute('aria-busy');
      if (!resp) { return; }
      if (("extractedbib" in resp) && (resp.extractedbib)) {
        this.mycard.extractbibmtime = Date.now();
      }
      this.mycard.updateuploadmain(resp.extension);
      if (this.mycard.filenames) {
        this.mycard.filenames.push('main.md');
      }
      if (this.mycard.updateproofblock) {
        this.mycard.updateproofblock();
      }
      this.mycard.openNext();
    }
  });
  card.uploadmaindownload = addelem({
    tag: 'button',
    type: 'button',
    role: 'button',
    mycard: card,
    parent: card.uploadmaingrid,
    innerHTML: '<span class="material-symbols-outlined">download</span>' +
      'download main uploaded file',
    onclick: function() {
      if (!this?.mycard?.mainuploadext ||
        !this?.mycard?.assignmentType ||
        !this?.mycard?.assignmentId ||
        this.mycard.mainuploadext == '') { return; }
      const filename = 'mainupload.' + this.mycard.mainuploadext;
      ogtf.editordownload(this.mycard.assignmentType,
        this.mycard.assignmentId,
        filename);
    }
  });
  card.updateuploadmain = function(ext) {
    this.mainuploadext = ext;
    if (ext != '') {
      this.uploadmainlabel.innerHTML = 'Replace main document ' +
        '(current one: ' + ext + ' file)';
      this.uploadmaindownload.style.visibility = 'visible';
      return;
    }
    this.uploadmainlabel.innerHTML = 'Upload main document ' +
      '(.docx, .odt, .rtf, .tex, .md, .epub)';
    this.uploadmaindownload.style.visibility = 'hidden';
  }
  card.updateuploadmain(card.mainuploadext);
  card.uploadsep = addelem({
    tag: 'p',
    parent: card.uploadinner
  });
  card.uploadauxlabel = addelem({
    tag: 'label',
    parent: card.uploadinner,
    innerHTML: 'Auxiliary files'
  });
  const auxfiles = filenames.filter((f) => {
    for (const regex of nonauxfiles) {
      if (regex.test(f)) { return false; }
    }
    return true;
  });
  card.uploadauxtable = addelem({
    tag: 'table',
    parent: card.uploadinner,
    classes: ['auxuploadtable']
  });
  card.uploadauxtable.setAttribute('role','grid');
  card.auxtbdy = addelem({
    tag: 'tbody',
    parent: card.uploadauxtable
  });
  card.addtoauxfilelist = function(auxfile) {
    const trow = addelem({
      tag: 'tr',
      parent: this.auxtbdy});
    const nametd = addelem({
      tag: 'td',
      innerHTML: auxfile,
      parent: trow});
    const btntd = addelem({
      tag: 'td',
      parent: trow});
    const dlbtn = addelem({
      tag: 'span',
      parent: btntd,
      classes: ['material-symbols-outlined'],
      mycard: this,
      myfilename: auxfile,
      innerHTML: 'download',
      title: 'download',
      onclick: function() {
        ogtf.editordownload(this.mycard.assignmentType,
          this.mycard.assignmentId,
          this.myfilename);
      }
    });
    const delbtn = addelem({
      tag: 'span',
      parent: btntd,
      mycard: this,
      myrow: trow,
      myfilename: auxfile,
      classes: ['material-symbols-outlined'],
      innerHTML: 'delete_forever',
      title: 'delete',
      onclick: async function() {
        const req = {};
        req.postcmd = 'deletefile';
        req.assignmentId = this.mycard.assignmentId;
        req.assignmentType = this.mycard.assignmentType;
        req.filetodelete = this.myfilename;
        this.classList.remove('material-symbols-outlined');
        this.innerHTML = 'deleting';
        this.setAttribute('aria-busy', 'true');
        let resp = await ogtf.editorquery(req);
        this.removeAttribute('aria-busy');
        this.classList.add('material-symbols-outlined');
        this.innerHTML = 'delete_forever';
        if (!resp) { return; }
        this.myrow.parentNode.removeChild(this.myrow);
        if (this?.mycard?.editotherTbody) {
          const aa = this.mycard.editotherTbody
            .getElementsByTagName("a");
          for (const a of aa) {
            if (a.innerHTML == this.myfilename) {
              const trow = a.parentNode.parentNode;
              trow.parentNode.removeChild(trow);
            }
          }
        }
      }
    });
  }
  for (const auxfile of auxfiles) {
    card.addtoauxfilelist(auxfile);
  }
  card.uploadauxgrid = addelem({
    tag: 'div',
    parent: card.uploadinner
  });
  card.uploadauxgridright = addelem({
    tag: 'div',
    classes: ['fakegrid'],
    parent: card.uploadauxgrid
  });
  card.uploadauxfilelabel = addelem({
    tag: 'label',
    parent: card.uploadauxgridright,
    innerHTML: 'Upload auxiliary file(s):'
  });
  card.uploadauxgridwaiting = addelem({
    tag: 'span',
    parent: card.uploadauxgridright,
    innerHTML: 'uploading …'
  });
  card.uploadauxgridwaiting.setAttribute('aria-busy', 'true');
  card.uploadauxgridwaiting.style.display = 'none';
  card.uploadauxfileinput = addelem({
    tag: 'input',
    type: 'file',
    parent: card.uploadauxgridright,
    mycard: card,
    multiple: true,
    onchange: async function() {
      if (this.value == '') { return; }
      if (!this?.mycard?.assignmentId) {
        this.mycard.reporterror('Cannot upload a file until a ' +
          'document id has been set.');
        return;
      }
      this.mycard.clearmessage();
      const req = {};
      req.uploadtype = 'auxfiles';
      req.assignmentType = this.mycard.assignmentType;
      req.assignmentId = this.mycard.assignmentId;
      this.mycard.uploadauxgridwaiting.style.display = 'inline-block';
      this.style.display = 'none';
      const resp = await ogtf.editorupload(this, req);
      this.mycard.uploadauxgridwaiting.style.display = 'none';
      this.style.display = 'inline';
      if (!resp) { return; }
      const inpfiles = this.files;
      for (const file of this.files) {
        this.mycard.addtoauxfilelist(file.name);
        if (iseditable(file.name)) {
          if (this?.mycard?.addtoeditlist) {
            this.mycard.addtoeditlist(file.name);
          }
        }
      }
    }
  });
  //
  // Bibliography block
  //
  card.bibblock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.biblabel = addelem({
    tag: 'summary',
    parent: card.bibblock,
    innerHTML: 'Bibliography'
  });
  card.bibinner = addelem({
    tag: 'div',
    classes: ['grid'],
    parent: card.bibblock
  });
  card.bibinner.setAttribute('role', 'grid');
  card.editbibBtn = addelem({
    tag: 'a',
    href: (assignmentId.includes('ogtfnew')) ? '#bibliography'
      : `#bibliography-${assignmentType}-${assignmentId}`,
    parent: card.bibinner,
    innerHTML: 'edit bibliography (this tab)'
  });
  card.editbibBtn.setAttribute('role', 'button');
  card.editbibntBtn = addelem({
    tag: 'a',
    target: "_blank",
    href: (assignmentId.includes('ogtfnew')) ? '#bibliography'
      : `#bibliography-${assignmentType}-${assignmentId}`,
    parent: card.bibinner,
    innerHTML: 'edit bibliography (new tab)'
  });
  card.editbibntBtn.setAttribute('role', 'button');
  //
  // Edit block
  //
  card.editblock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.editlabel = addelem({
    tag: 'summary',
    parent: card.editblock,
    innerHTML: 'Edit document'
  });
  card.editinner = addelem({
    tag: 'div',
    parent: card.editblock
  });

  // edit main file
  card.editmainfilelabel = addelem({
    tag: 'div',
    innerHTML: 'Edit main file',
    classes: ['editmainfilelabel'],
    parent: card.editinner,
  });
  card.editanywaymsg = addelem({
    tag: 'p',
    parent: card.editinner
  });
  card.editmainlink = addelem({
    tag: 'a',
    innerHTML: 'edit main document <span class="material-symbols-' +
      'outlined">edit_note</span>',
    classes: ['editmainbutton'],
    target: '_blank',
    parent: card.editinner
  })
  card.editmainlink.setAttribute('role', 'button');
  card.updateeditsection = function() {
    const card = this;
    if (!card?.assignmentId) {
      card.editmainlink.style.display = 'none';
      card.editanywaymsg.style.display = 'block';
      card.editanywaymsg.innerHTML = '(A document id must be ' +
        'set, and a main document uploaded, before it ' +
        'can be edited.)';
      return;
    }
    const mainlink = editUrl(this.assignmentType,
      this.assignmentId, 'main.md');
    if (card.filenames.indexOf('main.md') == -1 &&
        card.mainuploadext == '') {
      card.editmainlink.style.display = 'none';
      card.editanywaymsg.style.display = 'block';
      card.editanywaymsg.innerHTML = '';
      addelem({
        tag: 'span',
        parent: card.editanywaymsg,
        innerHTML: '(A main document has not been uploaded ' +
          'yet. If you would really like to create a blank ' +
          'one from scratch anyway, you can '
      });
      addelem({
        tag: 'a',
        parent: card.editanywaymsg,
        href: '#',
        innerHTML: 'click here',
        mycard: card,
        mylink: mainlink,
        onmousedown: function(e) { e.preventDefault(); },
        onclick: async function(e) {
          e.preventDefault();
          const card = this.mycard;
          card.editmainlink.style.display = 'block';
          card.editmainlink.setAttribute('aria-busy', 'true');
          card.editmainlink.innerHTML = 'creating …';
          const req = {
            postcmd: 'createblankmain',
            assignmentId: card.assignmentId,
            assignmentType: card.assignmentType
          }
          const resp = await ogtf.editorquery(req);
          card.editmainlink.innerHTML = 'edit main document ' +
            '<span class="material-symbols-outlined">' +
            'edit_note</span>';
          card.editmainlink.removeAttribute('aria-busy');
          if (!resp) { return; }
          card.filenames.push('main.md');
          window.open(this.mylink, "_blank");
          card.updateeditsection();
          if (card.updateproofblock) {
            card.updateproofblock();
          }
        }
      });
      addelem({
        tag: 'span',
        parent: card.editanywaymsg,
        innerHTML: '.)'
      });
      return;
    }

    if (card.biblastapplied == -1) {
      card.editmainlink.style.display = 'none';
      card.editanywaymsg.style.display = 'block';
      card.editanywaymsg.innerHTML =
        '(The bibliography has not been applied to the main ' +
        'file yet. Click <a href="' + mainlink + '" target="_blank">' +
        'here to edit the main file</a> anyway.)';
      return;
    }
    card.editmainlink.style.display = 'block';
    card.editanywaymsg.style.display = 'none';
    card.editmainlink.href = mainlink;
  }
  card.updateeditsection();
  card.editsep = addelem({
    tag: 'p',
    parent: card.editinner
  });
  card.editotherlabel = addelem({
    tag: 'label',
    parent: card.editinner,
    innerHTML: 'Edit other files'
  });
  card.editsep.style.display = 'none';
  card.editotherlabel.style.display = 'none';
  card.editothertable = addelem({
    tag: 'table',
    parent: card.editinner
  });
  card.editothertable.setAttribute('role', 'grid');
  card.editotherTbody = addelem({
    tag: 'tbody',
    parent: card.editothertable
  });
  card.addtoeditlist = function(fn) {
    if (!this?.assignmentId) { return; }
    this.editsep.style.display = 'block';
    this.editotherlabel.style.display = 'block';
    let warningToUse = '';
    for (const [re, warning] of editwarnings) {
      if (re.test(fn)) {
        warningToUse = warning;
        break;
      }
    }
    if (warningToUse === false) { return; }
    const trow = addelem({
      tag: 'tr',
      parent: this.editotherTbody
    });
    const warntd = addelem({
      tag: 'td',
      classes: ['warncell'],
      parent: trow
    });
    const edittd = addelem({
      tag: 'td',
      parent: trow,
      classes: ['editcell'],
      innerHTML: '<a href="' + editUrl(this.assignmentType,
        this.assignmentId, fn) + '" target="_blank" ' +
        'title="edit this file" ' +
        'class="material-symbols-outlined">edit_note</a>'
    });
    const fntd = addelem({
      tag: 'td',
      parent: trow,
      classes: ['fncell'],
      innerHTML: '<a href="' + editUrl(this.assignmentType,
        this.assignmentId, fn) + '"target="_blank"' +
        ' title="edit this file">' + fn + '</a>'
    });
    if (warningToUse != '') {
      warntd.setAttribute('data-tooltip', warningToUse);
      edittd.setAttribute('data-tooltip', warningToUse);
      fntd.setAttribute('data-tooltip', warningToUse);
      trow.classList.add('warningrow');
      warntd.innerHTML = '<span class="material-symbols-outlined">' +
        'warning</span>';
    }

  }
  const editnames = filenames.filter((f) => (iseditable(f)));
  for (const ename of editnames) {
    card.addtoeditlist(ename);
  }

  //
  // Proofs block
  //
  card.proofsblock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.proofslabel = addelem({
    tag: 'summary',
    parent: card.proofsblock,
    innerHTML: 'Proofs'
  });
  card.proofsinner = addelem({
    tag: 'div',
    parent: card.proofsblock
  });
  card.proofsets = [];
  if ("proofsets" in assignmentInfo) {
    card.proofsets = assignmentInfo.proofsets;
  }
  card.createproofsbtn = addelem({
    tag: 'button',
    type: 'button',
    innerHTML: 'create new proof set',
    mycard: card,
    parent: card.proofsinner,
    onclick: async function() {
      const card = this.mycard;
      // sanity checks
      if (!card?.assignmentId) {
        return;
      }
      if (card.filenames.indexOf('main.md') == -1) {
        return;
      }
      this.innerHTML = 'creating … (may take awhile)';
      this.setAttribute('aria-busy', 'true');
      const req = {
        assignmentId: card.assignmentId,
        assignmentType: card.assignmentType,
        postcmd: 'createproofset'
      }
      const resp = await ogtf.editorquery(req);
      this.removeAttribute('aria-busy');
      this.innerHTML = 'create new proof set';
      if (!resp) { return; }
      if (!("proofset" in resp)) { return; }
      if (card.proofsets) {
        card.proofsets.push(resp.proofset);
      }
      if (card.updateproofblock) {
        card.updateproofblock();
      }
    }
  });
  card.proofslabel = addelem({
    tag: 'div',
    parent: card.proofsinner
  });
  card.proofstable = addelem({
    tag: 'table',
    classes: ['proofslist','grid'],
    parent: card.proofsinner
  });
  card.proofstbdy = addelem({
    tag: 'tbody',
    parent: card.proofstable
  });
  card.updateproofblock = function() {
    const card = this;
    if (card.updatepubblock) {
      card.updatepubblock();
    }
    if (card.filenames.indexOf('main.md') == -1) {
      card.createproofsbtn.style.display = 'none';
      card.proofstable.style.display = 'none';
      card.proofslabel.style.display = 'block';
      card.proofslabel.innerHTML = '(Proofs can only be created ' +
        'once the main document has been uploaded, converted ' +
        '(or created) and edited.)';
      return;
    }

    card.createproofsbtn.style.display = 'block';
    if (card.proofsets.length == 0) {
      card.proofstable.style.display = 'none';
      card.proofslabel.style.display = 'none';
      return;
    }
    card.proofstable.style.display = 'table';
    card.proofslabel.style.display = 'block';
    card.proofslabel.innerHTML = 'Existing Proof Sets';
    card.proofstbdy.innerHTML = '';
    card.proofsets = card.proofsets.sort(function(a,b) {
      return (a.settime - b.settime);
    });
    let ctr=0;
    for (const proofset of card.proofsets) {
      ctr++;
      const ekey = proofset.ekey;
      const akey = proofset.akey;
      const ofiles = proofset.outputfiles;
      const ts = proofset.settime;
      const dto = new Date(ts);
      const timestr = dto.toLocaleString();
      const trow = addelem({ tag: 'tr', parent: card.proofstbdy });
      const timed = addelem({
        tag: 'td',
        parent: trow,
        innerHTML: ctr.toString() + '. Created ' + timestr
      });
      const elink = proofUrl(ekey);
      const alink = proofUrl(akey);

      const elinkd = addelem({
        tag: 'td',
        parent: trow,
        innerHTML: '<a href="' + elink + '" target="_blank">' +
          'editor link</a>'
      });
      const alinkd = addelem({
        tag: 'td',
        parent: trow,
        innerHTML: '<a href="' + alink + '" target="_blank">' +
          'author link</a>'
      });
      const dld = addelem({
        tag: 'td',
        parent: trow
      });
      const dldl = addelem({
        tag: 'span',
        parent: dld,
        innerHTML: 'downloads: '
      });
      for (const ofile of proofset.outputfiles) {
        const ext = ofile.split('.').reverse()[0];
        let ic = 'download';
        if (ext in exticons) {
          ic = exticons[ext];
        }
        const dlb = addelem({
          tag: 'span',
          parent: dld,
          classes: ['material-symbols-outlined', 'proofsdl'],
          innerHTML: ic,
          mycard: card,
          title: 'download ' + ofile,
          onclick: function() {
            const card = this.mycard;
            ogtf.editordownload(card.assignmentType,
              card.assignmentId, 'proofs/' +
              ts.toString() + '/' + ofile);
          }
        });
      }
    }
  }
  card.updateproofblock();
  //
  // Publication block
  //
  card.pubblock = addelem({
    tag: 'details',
    parent: card.contents,
    classes: ['ogtf-assignmentblock']
  });
  card.publabel = addelem({
    tag: 'summary',
    parent: card.pubblock,
    innerHTML: 'Publication'
  });
  card.pubinner = addelem({
    tag: 'div',
    parent: card.pubblock
  });
  card.pubbuttondiv = addelem({
    tag: 'div',
    classes: ['grid'],
    parent: card.pubinner
  });
  card.createpubversion = async function(b) {
    const card=this;
    if (!b?.myversion) { return; }
    b.innerHTML = 'creating …';
    b.setAttribute('aria-busy', 'true');
    const req = {
      postcmd: 'createversion',
      assignmentId: card.assignmentId,
      assignmentType: card.assignmentType,
      version: b.myversion
    }
    const resp = await ogtf.editorquery(req);
    b.removeAttribute('aria-busy');
    b.innerHTML = 'create version ' + b.myversion;
    if (!resp) { return; }
    if ("versioninfo" in resp) {
      card.editions[b.myversion] = resp.versioninfo;
    }
    if (card.updatepubblock) {
      card.updatepubblock();
    }
  }
  card.pubminordiv = addelem({ tag: 'div', parent: card.pubbuttondiv });
  card.pubminorbtn = addelem({
    tag: 'button',
    type: 'button',
    parent: card.pubminordiv,
    mycard: card,
    onclick: function() { this.mycard.createpubversion(this); }
  });
  card.pubmajordiv = addelem({ tag: 'div', parent: card.pubbuttondiv });
  card.pubmajorbtn = addelem({
    tag: 'button',
    type: 'button',
    parent: card.pubmajordiv,
    mycard: card,
    onclick: function() { this.mycard.createpubversion(this); }
  });
  card.editionslabel= addelem({
    tag: 'div',
    parent: card.pubinner
  });
  card.editionstable = addelem({
    tag: 'table',
    classes: ['editionstable'],
    parent: card.pubinner
  });
  card.editionstbdy = addelem({
    tag: 'tbody',
    parent: card.editionstable
  });
  card.pubextractdiv = addelem({
    tag: 'div',
    classes: ['pubversionextros'],
    parent: card.pubinner
  });
  card.pubextractdiv.style.display = 'none';
  card.editions = {};
  if ("editions" in assignmentInfo) {
    card.editions = assignmentInfo.editions;
  }
  card.updatepubblock = function() {
    const card=this;
    if (card.filenames.indexOf('main.md') == -1) {
      card.pubbuttondiv.style.display = 'none';
      card.editionstable.style.display = 'none';
      card.editionslabel.style.display = 'block';
      card.editionslabel.innerHTML = '(You cannot create a ' +
        'publication edition until you have uploaded (or ' +
        'created) a document and have edited it.)';
      return;
    }
    card.pubbuttondiv.style.display = 'grid';
    let major = 0;
    let minor = 0;
    while (( (major+1).toString() + '.0' ) in card.editions) {
      major++;
    }
    while (( major.toString() + '.' + (minor+1).toString()) in card.editions ) {
      minor++;
    }
    const nextmajor = (major+1).toString() + '.0';
    const nextminor = major.toString() + '.' + (minor+1).toString();

    card.pubminorbtn.myversion = nextminor;
    card.pubmajorbtn.myversion = nextmajor;
    card.pubminorbtn.innerHTML = 'create version ' + nextminor;
    card.pubmajorbtn.innerHTML = 'create version ' + nextmajor;

    let editionversions = Object.keys(card.editions);
    if (editionversions.length == 0) {
      card.editionslabel.style.display = 'none';
      card.editionstable.style.display = 'none';
      return;
    }
    card.editionslabel.style.display = 'block';
    card.editionstable.style.display = 'table';
    card.editionslabel.innerHTML = 'Publication editions';
    // sort editions
    editionversions = editionversions.sort(function(a,b) {
      const aparts = a.split('.');
      const bparts = b.split('.');
      if (parseInt(aparts[0]) != parseInt(bparts[0])) {
        return parseInt(aparts[0]) - parseInt(bparts[0]);
      }
      return parseInt(aparts[1]) - parseInt(bparts[0]);
    });
    card.editionstbdy.innerHTML ='';
    for (const version of editionversions) {
      const versioninfo = card.editions[version];
      const trow = addelem({tag: 'tr', parent: card.editionstbdy});
      let ctime = 'unknown';
      if ("creationtime" in versioninfo) {
        ctime = (new Date(versioninfo.creationtime))
          .toLocaleDateString();
      }
      const verstd = addelem({
        tag: 'td',
        parent: trow,
        innerHTML: '<strong>' + version + '</strong> (' + ctime + ')'
      });
      const ziptd = addelem({
        tag: 'td',
        classes: ['editiondownloads'],
        parent: trow
      });
      const dltd = addelem({
        tag: 'td',
        classes: ['editiondownloads'],
        parent: trow
      });
      const extrtd = addelem({
        tag: 'td',
        classes: ['editionextracts'],
        parent: trow
      });
      if (!("files" in versioninfo)) {
        continue;
      }
      let extractlist = '';
      for (const file of versioninfo.files) {
        const ext = file.split('.').reverse()[0];
        if (ext == 'txt') {
          if (extractlist != '') {
            extractlist += ', ';
          }
          extractlist += file.replace(/\.txt$/,'');
          continue;
        }
        let ic = 'download';
        if (ext in exticons) {
          ic = exticons[ext];
        }
        let parnode = dltd;
        if (ext == 'zip') { parnode = ziptd; };
        const dlb = addelem({
          tag: 'span',
          parent: parnode,
          classes: ['material-symbols-outlined', 'pubsdl'],
          innerHTML: ic,
          mycard: card,
          title: 'download ' + file,
          onclick: function() {
            const card = this.mycard;
            ogtf.editordownload(card.assignmentType,
              card.assignmentId, 'editions/' +
              version + '/' + file);
          }
        });
      }
      if (extractlist != '') {
        const extractlink = addelem({
          tag: 'a',
          parent: extrtd,
          innerHTML: 'extract ' + extractlist,
          href: '#',
          onmousedowndown: function(e) {
            e.preventDefault();
          },
          mycard: card,
          myversion: version,
          onclick: async function(e) {
            e.preventDefault();
            const card = this.mycard;
            card.pubextractdiv.style.display = 'block';
            card.pubextractdiv.innerHTML = this.innerHTML.replace('extract ','extracting ');
            card.pubextractdiv.setAttribute('aria-busy', 'true');
            const req = {
              postcmd: 'extractfromversion',
              assignmentId: card.assignmentId,
              assignmentType: card.assignmentType,
              version: this.myversion
            }
            const resp = await ogtf.editorquery(req);
            card.pubextractdiv.removeAttribute('aria-busy');
            card.pubextractdiv.innerHTML = '';
            if (!resp) { return; }
            if ("extractos" in resp) {
              for (const extracto in resp.extractos) {
                const label = addelem({
                  tag: 'label',
                  parent: card.pubextractdiv,
                  innerHTML: extracto
                });
                const textarea = addelem({
                  tag: 'textarea',
                  value: resp.extractos[extracto],
                  parent: card.pubextractdiv
                });
                const copybuttondiv = addelem({
                  tag: 'div',
                  parent: card.pubextractdiv,
                  classes: ['copybuttondiv']
                });
                const copybutton = addelem({
                  tag: 'a',
                  href: '#',
                  mytextarea: textarea,
                  parent: copybuttondiv,
                  innerHTML: 'copy to clipboard',
                  onmousedown: function(e) {
                    e.preventDefault();
                  },
                  onclick: function(e) {
                    e.preventDefault();
                    this.setAttribute('aria-busy', 'true');
                    this.innerHTML = 'copying';
                    if (navigator?.clipboard?.writeText) {
                      navigator.clipboard.writeText(this.mytextarea.value);
                    }
                    setTimeout(() => {
                      this.removeAttribute('aria-busy');
                      this.innerHTML = 'copied';
                    }, 100);
                  }
                });
                copybutton.setAttribute('role','button');
              }
            }
          }
        });
      }
    }
  }
  card.updatepubblock();

  // card message areas and associated functions

  card.reporterror = ogtf.reporterror.bind(ogtf);
  card.okmessage = ogtf.okmessage.bind(ogtf);
  card.clearmessage = ogtf.clearmessage.bind(ogtf);
  card.mainfilechanged = 0;
  if ("mainfilechanged" in assignmentInfo) {
    card.mainfilechanged = assignmentInfo.mainfilechanged;
  }
  card.openNext = function() {
    // close all accordians
    let dd = this.getElementsByTagName('details');
    for (const d of dd) {
      d.removeAttribute("open");
    }
    // do not open any of no assignmentId
    if (this.assignmentId == '') {
      return;
    }
    // no not open any if archived
    if (this.isarchived) {
      return;
    }
    if (!this.hasMetaData) {
      this.metablock.setAttribute("open", "open");
      return;
    }
    if (this.mainuploadext == '') {
      this.uploadblock.setAttribute("open", "open");
      return;
    }
    if (this.biblastapplied == -1) {
      this.bibblock.setAttribute("open", "open");
      return;
    }
    // once we get here we work upwards towards edit document
    let neededit = true;
    let ctime = 0;
    if (this?.editions && Object.keys(this.editions).length > 0) {
      neededit = false;
      for (const version in this.editions) {
        const versioninfo = this.editions[version];
        if (versioninfo?.creationtime > ctime) {
          ctime = versioninfo.creationtime;
        }
      }
      if (ctime != 0 && this.mainfilechanged > ctime) {
        this.pubblock.setAttribute("open", "open");
        return;
      }
    }
    if (this?.proofsets && this.proofsets.length > 0 && ctime == 0) {
      neededit = false;
      this.proofsblock.setAttribute("open", "open");
    }
    if (neededit) {
      this.editblock.setAttribute("open", "open");
    }
  }

  card.openNext();
  card.updateTitle();
  return card;
}


ogtf.assignmentpage = function(
  assignmentType, assignmentId, assignmentInfo
) {
  const main = byid('projectmain');
  const sect = addelem({
    tag: 'div',
    parent: main.contents,
    mytype: assignmentType,
    id: `#assignment-${assignmentType}-${assignmentId}`
  });
  const card = ogtf.assignmentcard(
    assignmentType, assignmentId, assignmentInfo, sect
  );
  return sect;
}

// function for user to change their email or name
ogtf.changedetails = async function() {
  const f = byid('changedetailsform');
  if (!f) { return; }
  const forminfo = getformfields(f);
  if (forminfo.anyinvalid) { return; }
  forminfo.postcmd = 'changedetails';
  // mark processing
  const b = byid('changedetailsbutton');
  b.innerHTML = 'changing';
  b.setAttribute('aria-busy', 'true');
  document.body.cursor = 'wait';
  // get info from server
  const respObj = await ogtf.editorquery(forminfo);
  // mark no longer processing
  b.removeAttribute('aria-busy');
  b.innerHTML = 'change';
  document.body.cursor = 'default';
  if (respObj?.success) {
    ogtf.okmessage('New details saved.', true);
  }
}

// function to switch between light/dark themes
ogtf.changetheme = function(mode = 'toggle') {
  const themetoggle = byid('themetoggle');
  const themetoggleicon = byid('themetoggleicon');
  if (mode === 'toggle') {
    mode = ((themetoggleicon.innerHTML.includes('light_mode')) ?
      'dark' : 'light');
  }
  document.documentElement.dataset.theme = mode;
  themetoggleicon.innerHTML = mode + '_mode</span>';
  themetoggle.blur();
}

// function to choose a project
ogtf.chooseproject = function(projectname) {
  if (projectname != '') {
    window.projectname = projectname;
    ogtf.updatenav();
  }
  ogtf.loadhash((window?.location?.hash ?? ''));
}

// clear the project main and set it up for something new;
// also marks it as loading
ogtf.clearmain = function() {
  const main = byid('projectmain');
  if (!window.isloggedin) {
    main.innerHTML = 'You do not have access to this ' +
      'when not logged in.';
    return;
  }
  // create buttons if they haven't been already
  if (!main?.hasbuttons) {
    main.innerHTML = '';
    const d = addelem({
      tag: 'div',
      parent: main,
      id: 'projectmainnav',
      classes: ['mainnav']
    });
    const currentbutton = addelem({
      parent: d,
      tag: 'a',
      id: 'currentbutton',
      href: '#current',
      innerHTML: 'current'
    });
    const archivebutton = addelem({
      parent: d,
      tag: 'a',
      id: 'archivedbutton',
      href: '#archived',
      innerHTML: 'archived'
    });
    const assignmentbutton = addelem({
      parent: d,
      tag: 'a',
      id: 'assignmentbutton',
      href: '#assignment',
      innerHTML: 'assignment'
    });
    const bibliographybutton = addelem({
      parent: d,
      tag: 'a',
      id: 'bibliographybutton',
      href: '#bibliography',
      innerHTML: 'bibliography'
    })
    const mydetailsbutton = addelem({
      parent: d,
      tag: 'a',
      id: 'mydetailsbutton',
      href: '#mydetails',
      innerHTML: 'my details'
    });
    const usersbutton = addelem({
      parent: d,
      tag: 'a',
      id: 'usersbutton',
      href: '#users',
      innerHTML: 'users'
    });
    for (const b of d.getElementsByTagName('a')) {
      b.setAttribute('role','button');
      b.classList.add('secondary');
    }
    main.msgdiv = addelem({
      tag: 'div',
      id: 'mainmsg',
      parent: main
    });
    main.msgdiv.style.display = 'none';
    main.loadingcard = addelem({
      tag: 'article',
      innerHTML: 'loading',
      parent: main
    });
    main.loadingcard.setAttribute('aria-busy', 'true');
    main.contents = addelem({
      parent: main,
      tag: 'section',
      id: 'projectcontents'
    });
    main.loading = function(l) {
      if (l) {
        main.loadingcard.style.display = 'block';
      } else {
        main.loadingcard.style.display = 'none';
      }
    }
    main.hasbuttons = true;
  }
  main.loading(true);
  main.contents.innerHTML = '';
  ogtf.clearmessage();
  // scroll to top
  byid('projecttitle').scrollIntoView();
}

ogtf.clearmessage = function() {
  const dd = document.getElementsByClassName("ogtfmsgdialog");
  if (!dd) return;
  for (const d of dd) {
    d.close();
    d.parentNode.removeChild(d);
  }
}

ogtf.editordownload = function(assignmenttype, assignmentid, filename) {
  if (ogtf.clearmessage) { ogtf.clearmessage(); }
  downloadFile(
    `/${window.urlbase}/download?project=` +
    encodeURIComponent(window.projectname) + '&username=' +
    encodeURIComponent(window.username) + '&accesskey=' +
    encodeURIComponent(window.loginaccesskey) + '&assignmentType=' +
    encodeURIComponent(assignmenttype) + '&assignmentId=' +
    encodeURIComponent(assignmentid) + '&filename=' +
    encodeURIComponent(filename),
    filename.split('/').pop()
  );
}

// generic function to make json requests, but only for logged in
// editors
ogtf.editorquery = async function(req) {
  if (ogtf.clearmessage) { ogtf.clearmessage(); }
  // always set postcmd in req
  if (!("postcmd" in req)) {
    console.error("Editor query made without postcmd.");
    return false;
  }
  req.username = window.username;
  req.accesskey = window.loginaccesskey;
  req.project = window.projectname;
  const resp = await postJSON(req);
  if (resp?.error || (!("respObj" in resp)) ||
      resp?.respObj?.error) {
    ogtf.reporterror('Error getting data from server. ' +
      (resp?.errMsg ?? '') + ' ' + (resp?.respObj?.errMsg ?? ''));
    return false;
  }
  return resp.respObj;
}

ogtf.editorupload = async function(inputelem, req) {
  if (!("uploadtype" in req)) {
    console.error("Upload request made without specifying type.");
    return false;
  }
  req.username = window.username;
  req.accesskey = window.loginaccesskey;
  req.project = window.projectname;
  const resp = await uploadFiles(inputelem, `/${window.urlbase}/upload`, req);
  if (resp?.error || (!("respObj" in resp)) ||
      resp?.respObj?.error) {
    ogtf.reporterror('Upload error. ' +
      (resp?.errMsg ?? '') + ' ' + (resp?.respObj?.errMsg ?? ''));
    return false;
  }
  return resp.respObj;
}

// clears login form and sets someone as the active user
ogtf.establishuser = function(respObj) {
  // reset login fields
  byid('ogtfname').removeAttribute("aria-invalid");
  byid('ogtfname').value='';
  byid('ogtfpwd').removeAttribute("aria-invalid");
  byid('ogtfpwd').value='';
  byid('ogtfremember').checked = false;
  byid('loginmsg').style.display = "none";
  window.isloggedin = true;
  window.username = respObj.loggedinuser;
  window.loginaccesskey = respObj.loginaccesskey;
  ogtf.updatenav();
  ogtf.loadhash((window?.location?.hash ?? ''));
}

// create a new user and invites them to set a password
ogtf.invitenewuser = async function() {
  const f = byid('newuserform');
  if (!f) { return; }
  const forminfo = getformfields(f);
  if (forminfo.anyinvalid) { return; }
  forminfo.postcmd = 'newuser';
  // mark processing
  const b = byid('newuserbutton');
  b.innerHTML = 'creating and inviting';
  b.setAttribute('aria-busy', 'true');
  document.body.cursor = 'wait';
  // set request to server
  const respObj = await ogtf.editorquery(forminfo);
  // reload from scratch
  // save bad info
  const mainmsg = byid("mainmsg").innerHTML;
  ogtf.clearmain();
  ogtf.showusers(false);
  if (respObj?.success) {
    ogtf.okmessage('Invitation sent.', true);
  }
}

// loads a given part of the framework depending on the #hash part of url
ogtf.loadhash = function(hash) {
  // this should be set if merely changing in url bar
  if (window.skiphashchange) {
    window.skiphashchange = false;
    return;
  }
  // safety checks
  const assignmentCards = document.getElementsByClassName("assignment");
  for (const card of assignmentCards) {
    if (card?.metadatachanged) {
      const dialog = metadatachangedialog({
        goto: hash,
        fromcard: card
      });
      return;
    }
  }
  const bibCards = document.getElementsByClassName("bibliographycard");
  for (const card of bibCards) {
    if (card?.biblastchanged && card?.biblastsaved &&
       (card.biblastchanged > card.biblastsaved)) {
      const dialog = bibchangeddialog({
        goto: hash,
        fromcard: card
      });
      return;
    }
  }
  // absolute top preference is to load newpwd if set by
  // url parameters
  if (("newpwdlink" in window) && window.newpwdlink != '') {
    ogtf.showview('newpwd');
    return;
  }
  // choosing a project and logging in always
  // take precedent
  if (window.projectname == '') {
    ogtf.showview('chooseproject');
    return;
  }
  if (!window.isloggedin) {
    if (hash == "#forgotpwd") {
      ogtf.showview("forgotpwd");
      return;
    }
    ogtf.showview('login');
    return;
  }
  // can always get new password screen if logged in
  if (hash == '#newpwd') {
    ogtf.showview('newpwd');
    return;
  }
  // everything else requires adding to the main element
  ogtf.loadprojectmain();
  if (hash == '#mydetails') {
    ogtf.showmydetails();
    return;
  }
  if (hash == '#users') {
    ogtf.showusers();
    return;
  }
  if (hash == '#current') {
    ogtf.showcurrent();
    return;
  }
  if (hash == '#archived') {
    ogtf.showarchived();
    return;
  }
  if (hash == '#assignment') {
    if (!ogtf?.currentassignment) {
      window.location.hash = '#current';
      return;
    }
    const newhash = `#assignment-` +
      `${ogtf.currentassignment.assignmentType}-` +
      `${ogtf.currentassignment.assignmentId}`;
    window.location.hash = newhash;
    return;
  }
  if (hash.startsWith('#assignment-')) {
    const hashinfo = hash.substr(12);
    const infoparts = hashinfo.split('-');
    const assignmentType = infoparts[0];
    const assignmentId = infoparts.slice(1).join('-');
    ogtf.showassignment(assignmentType, assignmentId);
    return;
  }
  if (hash == '#bibliography') {
    if (!ogtf?.currentassignment) {
      window.location.hash = '#current';
      return;
    }
    const newhash = `#bibliography-` +
      `${ogtf.currentassignment.assignmentType}-` +
      `${ogtf.currentassignment.assignmentId}`;
    window.location.hash = newhash;
    return;
  }
  if (hash.startsWith('#bibliography-')) {
    const hashinfo = hash.substr(14);
    const infoparts = hashinfo.split('-');
    const assignmentType = infoparts[0];
    const assignmentId = infoparts.slice(1).join('-');
    ogtf.showbibliography(assignmentType, assignmentId);
    return;
  }
  // default to current project page
  ogtf.showcurrent();
}

// clears the main area and shows it
ogtf.loadprojectmain = function() {
  ogtf.clearmain();
  ogtf.showview("projectmain");
  const main = byid("projectmain");
}

// sends a login request
ogtf.login = async function() {
  // get the important elements
  const form = byid('login').getElementsByTagName('form')[0];
  const btn = byid('login').getElementsByTagName('button')[0];
  // get the info from the login form
  const forminfo = getformfields(form);
  if (forminfo.anyinvalid) { return; }
  forminfo.project = window.projectname;
  forminfo.postcmd = 'login';
  // mark as processing
  btn.innerHTML = 'logging in';
  btn.setAttribute('aria-busy', 'true');
  document.body.style.cursor = 'wait';
  // wait for result
  const loginresult = await postJSON(forminfo);
  // change button back to normal
  btn.innerHTML = 'log in';
  btn.removeAttribute('aria-busy');
  document.body.style.cursor = 'default';
  // report fetch errors
  if (loginresult?.error || !loginresult?.respObj ||
      loginresult?.respObj?.error) {
    byid("loginmsg").style.display = "block";
    byid("loginmsg").innerHTML = 'Login error. ' +
      (loginresult?.errMsg ?? '') +
      (loginresult?.respObj?.errMsg ?? '');
    byid("login").getElementsByTagName("h2")[0]
      .scrollIntoView();
    return;
  }
  // report login errors
  const respObj = loginresult.respObj;
  if (!respObj?.success) {
    byid("loginmsg").style.display = "block";
    byid("loginmsg").innerHTML = 'Login error. ' +
      (respObj?.loginErrMsg ?? '');
    if (respObj?.nosuchuser) {
      byid('ogtfname').setAttribute("aria-invalid", "true");
      byid('ogtfname').addEventListener('change', function() {
        this.removeAttribute("aria-invalid");
      });
    }
    if (respObj?.wrongpassword) {
      byid('ogtfpwd').setAttribute("aria-invalid", "true");
      byid('ogtfpwd').addEventListener('change', function() {
        this.removeAttribute("aria-invalid");
      });
    }
    byid("login").getElementsByTagName("h2")[0]
      .scrollIntoView();
    return;
  }
  ogtf.establishuser(respObj);
}

// processes and sends a logout request
ogtf.logout = async function() {
  // mark button as processing
  const logoutbtn = byid("logoutbutton");
  logoutbtn.innerHTML = '';
  logoutbtn.setAttribute("aria-busy", "true");
  // do request
  const request = {
    postcmd: 'logout',
    username: window.username,
    project: window.projectname,
    accesskey: window.loginaccesskey
  }
  const logoutResp = await postJSON(request);
  // handle things browser-side
  window.username = '';
  window.isloggedin = false;
  window.loginaccesskey = '';
  // should delete everything in main so it can't be seen when
  // logged out
  ogtf.clearmain();
  const main = byid('projectmain');
  main.hasbuttons = false;
  // unmark button as processing
  logoutbtn.innerHTML = 'log out';
  logoutbtn.setAttribute("aria-busy", "false");
  // update navigation panel
  ogtf.updatenav();
  ogtf.showview('login');
  byid("loginmsg").style.display = "block";
  byid("loginmsg").innerHTML = "You have been logged out."
}


// puts a message which is not an error at top of projects page
ogtf.okmessage = function(okmsg, istoast = false) {
  if (istoast) {
    ogtf.showmessage(okmsg, 'toast');
    return;
  }
  ogtf.showmessage(okmsg, 'okmsg');
}

// create a dialog to confirm whether or not to remove a user
ogtf.removeuser = function(usertodie) {
  const main = byid('projectmain');
  const dialog = addelem({
    tag: 'dialog',
    id: 'killuserdialog',
    parent: main.contents
  });
  dialog.setAttribute('open', 'true');
  const artcl = addelem({
    tag: 'article',
    parent: dialog
  });
  const hdr = addelem({
    tag: 'h4',
    innerHTML: 'Do you really want to remove the user ' +
      usertodie + '?',
    parent: artcl
  });
  const ftr = addelem({
    tag: 'footer',
    parent: artcl
  });
  const cancelbtn = addelem({
    tag: 'a',
    classes: ['secondary'],
    innerHTML: 'cancel',
    href: '',
    parent: ftr,
    mymdl: dialog,
    onclick: function(e) {
      e.preventDefault();
      this.mymdl.parentNode.removeChild(this.mymdl);
    }
  });
  const killbtn = addelem({
    tag: 'a',
    innerHTML: 'confirm',
    myusertodie: usertodie,
    href: '',
    mymdl: dialog,
    parent: ftr,
    onclick: async function(e) {
      e.preventDefault();
      const usertodie = this.myusertodie;
      const req = {
        postcmd: 'killuser',
        usertodie: usertodie
      }
      // set processing
      this.innerHTML = 'removing';
      this.setAttribute('aria-busy', 'true');
      document.body.cursor = 'wait';
      // send request to sever
      const respObj = await ogtf.editorquery(req);
      // no longer processing
      document.body.cursor = 'default';
      // remove modal
      this.mymdl.parentNode.removeChild(this.mymdl);
      if (!respObj.success) { return; }
      // remove user from table
      const tbltbl = document.getElementsByClassName("userstable");
      if (!tbltbl) { return; }
      const tbl = tbltbl[0];
      const trtr = tbl.getElementsByTagName("tr");
      for (const trow of trtr) {
        const tdtd = trow.getElementsByTagName("td");
        if (!tdtd) { continue; }
        if (tdtd[0].innerHTML == usertodie) {
          trow.parentNode.removeChild(trow);
          ogtf.okmessage('user removed', false);
          break;
        }
      }
    }
  });
  cancelbtn.setAttribute('role','button');
  killbtn.setAttribute('role','button');
}

// puts an error message at top of projects section
ogtf.reporterror = function(errMsg) {
  ogtf.showmessage(errMsg, 'errmsg');
}

// sends a request to have password reset
ogtf.resetpwd = async function() {
  // read form
  const form = byid('forgotpwd').getElementsByTagName('form')[0];
  const forminfo = getformfields(form);
  if (forminfo.anyinvalid) { return; }
  // mark as processing
  const btn = byid('pwdresetbutton');
  btn.innerHTML = 'sending a password reset link';
  btn.setAttribute('aria-busy', 'true');
  document.body.style.cursor = 'wait';
  // request link
  const request = {
    postcmd: 'resetpwd',
    project: window.projectname,
    email: forminfo.ogtfpwdreset
  }
  const response = await postJSON(request);
  // no longer waiting
  btn.removeAttribute('aria-busy');
  btn.innerHTML = 'email a password reset link';
  // we show msg in any case
  const msg = byid('resetmsg');
  msg.style.display = 'block';

  // check for error
  document.body.style.cursor = 'default';
  if (response?.error || !("respObj" in response) ||
      response?.respObj?.error) {
    msg.innerHTML = 'Error requesting password reset. ' +
      (response?.errMsg ?? '') + ' ' +
      (response?.respObj?.errMsg ?? '');
    byid('forgotpwd').getElementsByTagName('h2')[0]
      .scrollIntoView();
    return;
  }
  // check for lack of success
  const respObj = response.respObj;
  if (!respObj.success) {
    msg.innerHTML = 'Error with password request. ' +
      (respObj?.resetErrMsg ?? '');
    byid('forgotpwd').getElementsByTagName('h2')[0]
      .scrollIntoView();
    return;
  }
  // it was successful, destroy the form
  form.innerHTML = '';
  msg.classList.add('okmsg');
  msg.innerHTML = 'Check your email in a minute or two ' +
    'for the reset link. You should close this tab now.';
}

// sends a request to change or set user password
ogtf.setnewpwd = async function() {
  const form = byid('newpwd').getElementsByTagName('form')[0];
  const forminfo = getformfields(form);
  if (forminfo.anyinvalid) { return; }
  if (forminfo.ogtfnewpwd1 != forminfo.ogtfnewpwd2) {
    const msg = byid("newpwdmsg");
    msg.style.display = "block";
    msg.innerHTML = "Passwords do not match.";
    return;
  }
  // mark as processing
  const btn = byid('newpwdbutton');
  btn.innerHTML = 'setting new password';
  btn.setAttribute('aria-busy', 'true');
  document.body.cursor = 'wait';
  // add to request
  forminfo.postcmd = 'newpwd';
  forminfo.newpwdlink = (window.newpwdlink ?? '');
  forminfo.accesskey = (window.loginaccesskey ?? '');
  forminfo.project = window.projectname;
  forminfo.username = window.username;
  forminfo.wasloggedin = window.isloggedin;
  //  make request
  const response = await postJSON(forminfo);
  // mark no longer waiting
  document.body.cursor = 'default';
  btn.innerHTML = 'set new password';
  btn.removeAttribute('aria-busy');
  // always show message afterwards
  const msg = byid("newpwdmsg");
  msg.style.display = "block";
  // check for errors
  if (response?.error || !("respObj" in response) ||
      response?.respObj?.error) {
    msg.innerHTML = "Error requesting new password. " +
      (response?.errMsg ?? '') +
      (response?.respObj?.errMsg ?? '');
    return;
  }
  // check for problems with request
  const respObj = response.respObj;
  if (!respObj?.success) {
    msg.innerHTML = 'Error setting new password. ' +
      (respObj?.pwdChangeErrMsg ?? '');
    return;
  }
  // success; destroy form
  form.innerHTML = '';
  msg.classList.add('okmsg');
  msg.innerHTML = 'Password changed. You should get an email confirmation.';
  window.newpwdlink = '';
  history.pushState(null, null, '?project=' + window.projectname);
  // in four seconds, redirect back to login form and reset form
  if (!window.isloggedin) {
    setTimeout(function() {
      ogtf.showview('login');
      byid('ogtfname').removeAttribute("aria-invalid");
      byid('ogtfname').value='';
      byid('ogtfpwd').removeAttribute("aria-invalid");
      byid('ogtfpwd').value='';
      byid('ogtfremember').checked = false;
      byid('loginmsg').style.display = "none";
    },
    4000);
  }
}

// show the current typesetting tasks
ogtf.showarchived = async function() {
  if (!window.isloggedin) { return; }
  // get information about current projects
  const resp = await ogtf.editorquery({ postcmd: 'allarchived' });
  // no longer loading
  const main = byid('projectmain');
  main.loading(false);
  ogtf.activebutton('archived');
  // if fetching failed, there's nothing to do; the editor query
  // should be showing an error
  if (!resp || resp.error) return;
  ogtf.clearmessage();
  // header
  const hdr = addelem({
    tag: 'h2',
    innerHTML: 'Archived Typesetting Assignments',
    parent: main.contents
  });
  delete(resp.error);
  ogtf.showassignments(resp, true);
}

ogtf.showassignment = async function(assignmentType, assignmentId) {
  if (!window.isloggedin) return;
  let assignmentInfo = {};
  if (!assignmentId.endsWith('ogtfnew')) {
    const resp = await ogtf.editorquery({
      postcmd: 'assignmentinfo',
      assignmentType: assignmentType,
      assignmentId: assignmentId
    });
    if (!resp || resp?.error) return;
    if (resp?.meinongian) {
      window.location.hash = `#assignment-${assignmentType}-ogtfnew`;
      return;
    }
    assignmentInfo = resp;
  }
  const main = byid('projectmain');
  main.loading(false);
  ogtf.activebutton('assignment');
  ogtf.clearmessage();
  ogtf.assignmentpage(assignmentType, assignmentId, assignmentInfo);
  ogtf.currentassignment = {
    assignmentType: assignmentType,
    assignmentId: assignmentId
  }
}

// TODODODO
// generic function for showing list assignments, either archived
// or current

ogtf.showassignments = function(assignments, isarchived = false) {
  const main = byid('projectmain');
  const projectSettings = window.projects[window.projectname];
  const assignmentTypes = projectSettings.assignmentTypes ?? {};
  for (const assignmentType in assignmentTypes) {
    const assignTypeSpec = assignmentTypes[assignmentType];
    const assignmentTypeInfo = assignments[assignmentType];
    const display = assignTypeSpec.display;
    const sect = addelem({
      tag: 'section',
      parent: main.contents,
      isarchived: isarchived,
      mytype: assignmentType
    });
    sect.hdr = addelem({
      tag: 'h3',
      innerHTML: assignmentType.charAt(0).toUpperCase() +
        assignmentType.substr(1) + 's',
      parent: sect
    });
    if (!isarchived) {
      sect.showAllLabel = addelem({
        tag: 'label',
        parent: sect,
        classes: ['showallcbblock']
      });
      sect.showallCB = addelem({
        tag: 'input',
        type: 'checkbox',
        parent: sect.showAllLabel,
        onchange: function() {
          this.mytable.classList
            [(this.checked) ? 'add' : 'remove']("showall");
        }
      });
      const cblabel = addelem({
        tag: 'span',
        parent: sect.showAllLabel,
        innerHTML: `show ${assignmentType}s assigned to others`
      })
    }
    sect.table = addelem({
      tag: 'table',
      classes: ['assignmenttable'],
      parent: sect
    });
    if (sect?.showallCB) {
      sect.showallCB.mytable = sect.table;
    }
    const tbdy = addelem({
      tag: 'tbody',
      parent: sect.table
    });
    for (const assignment in assignmentTypeInfo) {
      const metadata = assignmentTypeInfo?.[assignment]?.metadata ?? {};
      let mydisplay = display;
      for (const f in metadata) {
        if (!metadata[f] || metadata[f] == '') continue;
        if (typeof (metadata[f]) == 'string') {
          mydisplay = mydisplay.replaceAll(f.toUpperCase(), metadata[f]);
        } else if (typeof(metadata[f]) == "number") {
          mydisplay = mydisplay.replaceAll(f.toUpperCase(), metadata[f].toString());
        } else if (f == 'author' || f == 'editor') {
          const names = metadata[f].map((n) => (n.name)).join(', ');
          mydisplay = mydisplay.replaceAll(f.toUpperCase(), names);
        }
      }
      const assignmentrow = addelem({
        tag: 'tr',
        parent: tbdy
      });
      const assignedto = assignmentTypeInfo?.[assignment]?.assignedTo;
      const assignedname = assignmentTypeInfo?.[assignment]?.assignedToName;
      if (assignedto && assignedto != window.username) {
        assignmentrow.classList.add('othersassignment');
      }
      const assignmenttd = addelem({
        tag: 'td',
        parent: assignmentrow
      });
      const archiveButton = addelem({
        tag: 'button',
        type: 'button',
        role: 'button',
        classes: ['outline'],
        isarchived: isarchived,
        //mycard: card,
        parent: assignmenttd,
        innerHTML: ((isarchived) ? 'un' : '') + 'archive',
        assignmentId: assignment,
        assignmentType: assignmentType,
        mytr: assignmentrow,
        onclick: async function() {
          if (!this.assignmentId) {
            ogtf.reporterror('Cannot archive a document without an ID.');
            return;
          }
          const req = {};
          req.postcmd = 'archive';
          req.makearchived = (!this.isarchived);
          req.assignmentType = this.assignmentType;
          req.assignmentId = this.assignmentId;
          if (req.makearchived) {
            this.innerHTML = 'archiving …';
          } else {
            this.innerHTML = 'unarchiving …';
          }
          this.setAttribute('aria-busy', 'true');
          const resp = await ogtf.editorquery(req);
          this.removeAttribute('aria-busy');
          this.innerHTML = ((this.isarchived) ? 'un' : '') + 'archive';
          if (!resp) { return; }
          this.mytr.parentNode.removeChild(this.mytr);
        }
      });
      const link = addelem({
        tag: 'a',
        parent: assignmenttd,
        innerHTML: `<strong>(${assignment})</strong> ` + ((display == mydisplay) ? '' : mydisplay),
        href: `#assignment-${assignmentType}-${assignment}`
      });
      link.setAttribute('data-tooltip', `view ${assignmentType} ${assignment}`);
      const assignedtop = addelem({
        tag: 'p',
        classes: ['assignmentlisttowhom'],
        parent: assignmenttd,
        innerHTML: (assignedname) ? `(assigned to ${assignedname})` : ''
      });
    }

    if (isarchived) sect.table.classList.add('showall');

    if (!isarchived) {

      sect.newassignmentButton = addelem({
        tag: 'a',
        type: 'button',
        innerHTML: 'add new ' + assignmentType,
        parent: sect,
        href: `#assignment-${assignmentType}-ogtfnew`
      });
      sect.newassignmentButton.setAttribute('role', 'button');
    }
  }
}

ogtf.showbibliography = async function(assignmentType, assignmentId) {
  if (!window.isloggedin) return;
  let assignmentInfo = {};
  if (assignmentId.endsWith('ogtfnew')) {
    window.location.hash =
      window.location.hash.replace('#bibliography-','#assignment-');
    return;
  }
  const resp = await ogtf.editorquery({
    postcmd: 'assignmentinfo',
    assignmentType: assignmentType,
    assignmentId: assignmentId
  });
  if (!resp || resp?.error) return;
  if (resp?.meinongian) {
    window.location.hash = `#current`;
    return;
  }
  assignmentInfo = resp;
  const main = byid('projectmain');
  main.loading(false);
  ogtf.activebutton('bibliography');
  ogtf.clearmessage();
  main.sect = addelem({
    tag: 'div',
    parent: main.contents,
    mytype: assignmentType,
    id: `#bibliography-${assignmentType}-${assignmentId}`
  });
  bibpage({
    ogtf: ogtf,
    assignmentId: assignmentId,
    assignmentType: assignmentType,
    assignmentInfo: assignmentInfo,
    parent: main.sect
  })
  ogtf.currentassignment = {
    assignmentType: assignmentType,
    assignmentId: assignmentId
  }
}

// show the current typesetting tasks
ogtf.showcurrent = async function() {
  if (!window.isloggedin) return;
  // get information about current projects
  const resp = await ogtf.editorquery({ postcmd: 'allcurrent' });
  // no longer loading
  const main = byid('projectmain');
  main.loading(false);
  // if fetching failed, there's nothing to do; the editor query
  // should be showing an error
  if (!resp) { return; }
  // start with fresh screen, make "current" button the active one
  ogtf.clearmessage();
  ogtf.activebutton('current');
  // header
  const hdr = addelem({
    tag: 'h2',
    innerHTML: 'Current Typesetting Assignments',
    parent: main.contents
  });
  delete(resp.error);
  ogtf.showassignments(resp, false);
}

ogtf.showmessage = function(msg, cl) {
  const dialog = addelem({
    parent: document.body,
    tag: 'dialog',
    classes: ['ogtfmsgdialog']
  });
  const art = addelem({
    parent: dialog,
    tag: 'div',
    classes: ['ogtfmessageholder']
  });
  const msgdiv = addelem({
    parent: art,
    classes: ['ogtfmessage', cl],
    tag: 'div',
    innerHTML: msg
  });
  const ftr = addelem({
    tag: 'footer',
    parent: art
  });
  const closebtn = addelem({
    tag: 'button',
    type: 'button',
    parent: ftr,
    innerHTML: 'close',
    classes: ['secondary'],
    onclick: () => {
      dialog.close();
      dialog.parentNode.removeChild(dialog);
    }
  });
  closebtn.setAttribute('role', 'button');
  dialog.showModal();
  if (cl == 'toast') {
    setTimeout(() => {
      if (!dialog?.parentNode) return;
      dialog.close();
      dialog.parentNode.removeChild(dialog);
    }, 3000);
  }
}

// shows "my details" section under main
ogtf.showmydetails = async function() {
  if (!window.isloggedin) return;
  const detresp = await ogtf.editorquery({ postcmd: 'mydetails' });
  const main = byid('projectmain');
  main.loading(false);
  if (!detresp || !detresp?.mydetails) return;
  const mydetails = detresp.mydetails;
  ogtf.clearmessage();
  ogtf.activebutton('mydetails');
  const hdr = addelem({
    tag: 'h2',
    parent: main.contents,
    innerHTML: 'Editor details'
  });
  const form = addelem({
    tag: 'form',
    id: 'changedetailsform',
    parent: main.contents
  });
  form.onsubmit = function(e) { e.preventDefault(); };
  const namelbl = addelem({
    tag: 'label',
    parent: form,
    innerHTML: 'Name'
  });
  const nameinp = addelem({
    id: 'detailsname',
    name: 'detailsname',
    type: 'text',
    tag: 'input',
    required: 'true',
    value: mydetails.name,
    parent: namelbl
  });
  const emaillbl = addelem({
    tag: 'label',
    parent: form,
    innerHTML: 'Email'
  });
  const emailinp = addelem({
    id: 'detailsemail',
    name: 'detailsemail',
    type: 'email',
    tag: 'input',
    required: 'true',
    value: mydetails.email,
    parent: emaillbl
  });
  const changeButton = addelem({
    id: 'changedetailsbutton',
    tag: 'button',
    type: 'button',
    innerHTML: 'change',
    parent: form,
    onclick: function(e) {
      ogtf.changedetails();
    }
  });
  const pwdchangelink = addelem({
    id: 'changepwdlink',
    innerHTML: 'change password',
    tag: 'a',
    parent: form,
    href: '#newpwd'
  });
}

// shows the "user" section under main
ogtf.showusers = async function(cm = true) {
  if (!window.isloggedin) { return; }
  const usersresp = await ogtf.editorquery({
    postcmd: 'allusers'
  });
  const main = byid('projectmain');
  main.loading(false);
  if (!usersresp || !usersresp?.usersinfo) { return; }
  const usersinfo = usersresp.usersinfo;
  if (cm) { ogtf.clearmessage(); }
  ogtf.activebutton('users');
  const hdr = addelem({
    tag: 'h2',
    parent: main.contents,
    innerHTML: 'Site users'
  });
  // table of current users
  const tbl = addelem({
    tag: 'table',
    classes: ['userstable'],
    parent: main.contents
  });
  tbl.setAttribute("role","grid");
  const tbody = addelem({
    tag: 'tbody',
    parent: tbl
  });
  for (const usrname of Object.keys(usersinfo).sort(
    (a, b) => (a.localeCompare(b))
  )) {
    const trow = addelem({
      tag: 'tr',
      parent: tbody
    });
    const unamecell = addelem({
      tag: 'td',
      parent: trow,
      innerHTML: usrname
    });
    const necell = addelem({
      tag: 'td',
      parent: trow,
      innerHTML: '<span>' + usersinfo[usrname].name + '</span>' +
        '<br><span>(<a href="mailto:' + usersinfo[usrname].email +
        '">' + usersinfo[usrname].email + '</a>)</span>',
      classes: ['userinfocell']
    });
    const killcell = addelem({
      tag: 'td',
      parent: trow,
      title: 'remove user',
      innerHTML: '<span class="material-symbols-outlined">' +
        'delete_forever</span>',
      myusername: usrname,
      onclick: function() {
        ogtf.removeuser(this.myusername);
      }
    });
  }

  // new user form
  const subhdr = addelem({
    tag: 'h3',
    parent: main.contents,
    innerHTML: 'Invite a new user'
  });
  const form = addelem({
    tag: 'form',
    id: 'newuserform',
    parent: main.contents
  });
  form.onsubmit = function(e) { e.preventDefault(); };
  const namelbl = addelem({
    tag: 'label',
    parent: form,
    innerHTML: 'Name'
  });
  const nameinp = addelem({
    id: 'newname',
    name: 'newname',
    type: 'text',
    tag: 'input',
    required: 'true',
    placeholder: 'full name',
    parent: namelbl
  });
  const emaillbl = addelem({
    tag: 'label',
    parent: form,
    innerHTML: 'Email'
  });
  const emailinp = addelem({
    id: 'newemail',
    name: 'newemail',
    type: 'email',
    tag: 'input',
    required: 'true',
    placeholder: 'email address',
    onchange: function() {
      this.myusernameinput.value =
        this.value.replace(/@.*/,'')
        .replace(/[^A-Za-z0-9]/g,'').toLowerCase();
    },
    parent: emaillbl
  });
  const usernamelbl = addelem({
    tag: 'label',
    parent: form,
    innerHTML: 'Username (short log in name)'
  });
  const usernameinp = addelem({
    id: 'newusername',
    name: 'newusername',
    type: 'text',
    tag: 'input',
    required: 'true',
    placeholder: 'username',
    parent: usernamelbl
  });
  emailinp.myusernameinput = usernameinp;
  usernameinp.setAttribute('pattern','^[a-zA-Z0-9]*$');
  const newuserButton = addelem({
    id: 'newuserbutton',
    tag: 'button',
    type: 'button',
    innerHTML: 'invite new user',
    parent: form,
    onclick: function(e) {
      ogtf.invitenewuser();
    }
  });
}

// show a current part of the page and hides the others
ogtf.showview = function(id) {
  const vv = document.getElementsByClassName("ogtfview");
  for (const v of vv) {
    v.style.display='none';
  };
  byid(id).style.display = 'block';
}

// function to update the top navigation
ogtf.updatenav = function() {
  if (window.isloggedin) {
    byid('logoutbutton').parentNode.style.display = 'inline-block';
  } else {
    byid('logoutbutton').parentNode.style.display = 'none';
  }
  if (window.projectname != '') {
    const spsp = byid('projecttitle').getElementsByTagName("span");
    if (!spsp) { return; }
    spsp[0].innerHTML = window.projects[window.projectname].title;
    spsp[1].style.display = 'inline';
    document.title = window.projects[window.projectname]
      .title + ' Typesetting Framework';
  }
}

//
// Things to do at load
//

// attach hash change listener; lets hashes work with back button
window.skiphashchange = false;
window.onhashchange = function(e) {
  ogtf.loadhash(window?.location?.hash ?? '');
}

// make project title go to main project page or login, etc.
byid("projecttitle").onclick = function(e) {
  if (window.location.hash != '') {
    window.location.hash = '';
    return;
  }
  ogtf.loadhash('');
}

// determine which color theme to start in
const wantsDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
ogtf.changetheme((wantsDark) ? 'dark' : 'light');

// start by loading the appropriate part of the document, or force
// choice of project and login
ogtf.loadhash(window?.location?.hash ?? '');

// set the nav and title appropriately
ogtf.updatenav();

// export the ogtf object with all its functions
export default ogtf;
